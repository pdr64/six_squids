<!DOCTYPE html>
  <html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
    <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.7.0/css/font-awesome.min.css">
    <title> Lab 4</title>
    <style>
      body{
        padding: 0 80px;}
    </style>
</head>
  <body>
    <div id= "header">
      <center><h1> Lab 4 - FPGA and Color Detection</h1></center>
    </div>
    <div id = "navbar">
      <a href="https://pdr64.github.io/six_squids/"><button class="btn"><i class="fa fa-home"></i> Back to Home Page</button></a>
    </div>
    <br>
    <br>
    <center><h2>Objective </h2></center>
    <p>The objective of this lab was to use a camera hooked up to an FPGA to read in data from the camera and display it 
    on a screen, eventually analyzing the image for both color and shape to detect targets during competition</p>
    <br>
    <br>
    <center><h2>Materials Used</h2></center>
    <ul>
     <li>1 DE0-Nano FPGA</li>
     <li>2 Arduino Uno</li>
      <li>1 OV7670 camera</li>
      <li>VGA Adapter</li>
      <li>Wires and Jumper Cables</li>
    </ul>
    <br>
    <center><h2>Sub Teams</h2></center>
    <span><h3> Arduino/Camera Team</h3>
      <ul>
        <li>Katie</li>
        <li>Ben </li></ul></span>
    <span><h3>FPGA/Verilog</h3>
      <ul>
        <li> Caroline</li>
        <li> Pablo</li>
      </ul></span>
    <br>
    <center><h2>Procedure</h2></center>
    <h4>Getting the Cameras Operational</h4>
    <p>
      The first thing we did was get the Arduinos programmed to write registers to the camera. To do this we read through the 
      camera datasheet and found the right registers to set the data structure (RGB565), resolution (176x144), camera noise, using an 
      external clock, pixel format and more. We had difficulty with getting the right results from our camera and the problem proofed to be 
      from the registers we had set using outdated data sheet. Eventually, we were able to get the correct registers and a snippet of our
      code is shown below.
      <code><pre>
      Serial.println("Writing registers");
      Serial.println (OV7670_write_register(0x12, 0x80)); //COM7: Reset registers 
      delay(100);
      Serial.println(OV7670_write_register(0x12, 0x0E)); //COM7: Enable color bar, resolution and pixel format 
      Serial.println(OV7670_write_register(0x0C, 0x08)); //COM3: Enable scaling
      Serial.println(OV7670_write_register(0x14, 0x0B)); //COM9: To make the image less noisy
      Serial.println(OV7670_write_register(0x11, 0xC0)); //CLKRC: Use external clock directly 
      Serial.println(OV7670_write_register(0x40, 0xD0)); //COM15: Pixel format
      Serial.println(OV7670_write_register(0x42, 0x08)); //COM17: DSP color bar enable
      Serial.println(OV7670_write_register(0x1E, 0x30)); //MVFP: Vertically flip image enable
      </pre></code>
    </p>

    <h4>Getting Data from the Camera</h4>
    <p> To run the Arduino program, we needed to protect the camera. We had  to disable the internal pull-up resistors that are a part of
      the Arduinoâ€™s I2C interface. This is because they pull the signals that set up our camera to 5V, while our camera requires 3.3V.
      Sending 5V through will harm the camera. We did this by locating the twi.c file at C:\Program Files (x86)\Arduino\hardware\arduino\avr\libraries\Wire\src\utility.
      Then we commented out the following lines of code:
      <code><pre>
       //activate internal pullups for twi
       digitalWrite(SDA,1);
       digitalWrite(SCL,1);
      </pre></code>
      <br>
      We read the camera data and the picture below shows the output. Comparing the output to the written values into the registers, we confirmed that our camera was working 
      correctly and is ready to send data into the DE0-Nano FPGA.
      <!--image here-->
    </p>
    <br>
    <h3>Programming the FPGA to Read Camera Data</h3>
    <h4>Writing to M9K blocks</h4>
    <br>
    <h4>Downsampling</h4>
    <p>The information above about the camera indicates that the camera outputs a data structure of RGB565 which is 16 bits of information. We however need only 8 bits out of the 
      16 bits in order to save on memory. The Downsampling code collects all the data from the camera and selects only the most important bits necessary to display the colors we need.
      The OV7670 Camera can only output 8 bits of a pixel at a time through D7 - D0 (output connections). Using the camera clock cycle (see fig.2), we sampled down the output into RGB332.
      <center><img src="camera_clock.png" class="img-rounded" alt="Camera clock cycle" width="600" height="450">
      <p><b>Fig.1:</b> Clock cycle from the OV7670 Datasheet.This shows how the output from the clock is received based on time cycle</p></center>
      <br>Below is a snippet of our downsampler code. 
      <code><pre>
      //This set of codes receive camera data in RGB565 and downsamples it into RGB 332 by taking the important bits
      if (CAM_HREF_NEG) begin   //stuff has finished reading and clock has fallen
      	if (newByte ==1'b0) begin  //meaning we are reading the second 8 bit data set
        	temp[7:0] = data;        //receive what we have so we don't mess it up with new readings
            	W_EN = 1'b0;
           	X_ADDR = X_ADDR;         //save x address
           	newByte = 1'b1;           //change status
	end
	else begin
            	temp[15:8] = data;
            	pixel_data_RGB332 = {temp[15:13], temp[10:8], temp[4:3]};  //get all 8 bits of Red, Green and Blue
           	X_ADDR = X_ADDR + 10'b1; //increment x address
            	W_EN = 1'b1;
            	newByte = 1'b0;       //reset status
       end
      </pre></code>
    </p>
    <br>
    <h4>Reading Pixels</h4>
    <p>

    </p>
    <br>
   
    <br>
    <h4>Putting it all together</h4>
     <p>
    We wanted to read back to the Arduino data from the FPGA about the image such that the robot could report targets to the GUI 
       during competition. Therefore, we (did stuff on FPGA to analyze images) and sent that data in parallel back to the Arduino
       <br>
    When the Arduino recieves this data, it analyzed the information about whether or not there was a treasure, what color 
       it is, and the shape it is (out of 7 possible combinations) and eventually in milestone 4 we intend to include this in our search 
       path and incorporate it into the information we send to the GUI. 
    </p>
    <br>
    <br>
   <a href="#header"><button class="btn"><i class="fa fa-arrow-up"></i>Return to top</button></a>
       
 </body>
</html>
